Свойство display: flex, flex-элемент
Флексбокс — это первый CSS-механизм, предназначенный для построения сеток и создания сложных раскладок блоков.
Другие механизмы, с помощью которых мы раньше строили сетки, задумывались совсем не для этого: плавающие блоки нужны для создания блоков, которые текст должен обтекать, а таблицы используются для разметки табличных данных.
Флексбокс задумывался для создания «гибких» раскладок и хранит много тонкостей и чудес, о которых мы поговорим в этой серии глав. А пока начнём с простого. Как включить флексбокс?
Очень просто: нужно задать элементу свойство display: flex;. После этого происходит два события:

1. Элемент с display: flex; превращается во «флекс-контейнер» и внутри него начинает происходить вся магия гибкой раскладки.
2. Непосредственные потомки этого элемента превращаются во «флекс-элементы» и начинают играть по новым правилам.

Первое, что вы заметите, это то, что блоки растянутся на всю высоту контейнера. Да, внутри флексбокса можно делать элементы одинаковой высоты!


Свойство flex-direction, главная ось
Вспомните, как ведёт себя обычный поток документа. Блоки и текст располагаются слева направо и сверху вниз.
В привычной блочной модели направления «лево», «право», «верх» и «низ» неизменны. Но внутри флекс-контейнера эти понятия могут изменяться, потому что там можно изменять обычное направление потока.
Вместо направлений «лево» и «право» во флексбоксе используется понятие «главная ось». Поток флекс-элементов «течёт» вдоль главной оси от её начала к её концу.
По умолчанию главная ось направлена слева направо, но её можно разворачивать во всех направлениях с помощью свойства flex-direction, которое задаётся для флекс-контейнера. Значения свойства:

- row — значение по умолчанию, главная ось направлена слева направо.

- column — главная ось направлена сверху вниз.

- row-reverse — главная ось направлена справа налево.

- column-reverse — главная ось направлена снизу вверх.

Флекс-элементы всегда располагаются вдоль главной оси, независимо от её направления.


Поперечная ось flexbox
Вместо направлений «верх» и «низ» во флексбоксе используется понятие «поперечная ось». Вдоль этой оси работают «вертикальные» выравнивания.
Поперечная ось всегда перпендикулярна главной оси и поворачивается вместе с ней:

- Если главная ось направлена горизонтально, то поперечная ось смотрит вниз.
- Если главная ось направлена вертикально, то поперечная ось смотрит направо.
Это не совсем логичное поведение, к которому надо привыкнуть. Получается, что поперечная ось никогда не смотрит вверх или влево. А свойства для поворота поперечной оси нет.



Свойство justify-content, выравнивание вдоль главной оси
Вместо «горизонтального» выравнивания во флексбоксе используется свойство для распределения элементов вдоль главной оси — justify-content. Это свойство задаётся для флекс-контейнера.
Его значением по умолчанию является flex-start. При этом значении элементы располагаются у начала главной оси.
Чтобы элементы располагались по центру главной оси, нужно задать для justify-content значение center.


Свойство justify-content: flex-start | flex-end
Чтобы флекс-элементы располагались в начале главной оси, свойству justify-content нужно задать значение flex-start. Оно же является и значением по умолчанию.
А значение flex-end расположит элементы в конце главной оси.
Обратите внимание, что justify-content: flex-end не меняет порядок элементов, как это происходит при изменении направления оси flex-direction: row-reverse. Элементы просто прижимаются к концу главной оси.


Свойство justify-content: space-between | space-around
У флексбокса есть чем-то похожие значения justify-content, которые равномерно распределяют флекс-элементы вдоль главной оси:

-   space-between — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера отступов нет.

-   space-around — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера есть отступ, равный половине расстояния между соседними элементами.

Сейчас мы добавим третьего кота и поэкспериментируем с этими значениями justify-content.
А пока небольшой итог. Свойство justify-content управляет распределением элементов вдоль главной оси и имеет пять значений:

-   значение по умолчанию flex-start,

-   flex-end,

-   center,

-   space-between,

-   space-around.



Свойство align-items, выравнивание вдоль поперечной оси
Вместо «вертикального» выравнивания во флексбоксе используется свойство для выравнивания элементов вдоль поперечной оси — align-items. Это свойство задаётся для флекс-контейнера.
Его значением по умолчанию является stretch. Именно благодаря этому значению флекс-элементы и растягиваются на всю «высоту» флекс-контейнера. Если флекс-элементам задана высота, то растягиваться они не будут.
Чтобы элементы выровнялись по центру поперечной оси, нужно задать для align-items значение center.


Свойство align-items: flex-start | flex-end
Чтобы расположить флекс-элементы в начале или в конце поперечной оси, нужно использовать значения flex-start и flex-end для свойства align-items.
Эти значения аналогичны значениям свойства justify-content, отличается только ось.



Свойство align-items: baseline
Ещё одно значение свойства align-items — это baseline. Если задать его контейнеру, то флекс-элементы будут выравниваться по базовой линии текста в них. Эта воображаемая линия проходит по нижней части букв.
Если выровнять флекс-элементы по базовой линии, то они выстроятся так, чтобы текст в них был как бы на «одной строке».
Чтобы лучше понять поведение baseline, сравним его с другим значением — flex-start.
Мини-итог. Свойство align-items управляет выравниванием элементов вдоль поперечной оси и имеет пять значений:

-   значение по умолчанию stretch,

-   flex-start,

-   flex-end,

-   center,

-   baseline.


Свойство align-self, эгоистичное выравнивание
Распределение элементов по главной оси задаётся для всего флекс-контейнера и на все флекс-элементы действует одинаково. Задать какому-то элементу отличное от других распределение по главной оси нельзя. И это вполне логично, ведь тогда элементы будут «сталкиваться» друг с другом.
C поперечной осью всё проще. Можно сказать, что у каждого элемента она своя, и можно задавать им разное поперечное выравнивание. Для этого используется свойство align-self, которое задаётся для самих флекс-элементов, а не для флекс-контейнера.
У свойства align-self те же самые значения, что и у align-items.


Свойство align-self: baseline
Аналогично align-items для отдельного флекс-элемента можно задать и выравнивание по базовой линии с помощью align-self со значением baseline.


Свойство flex-wrap, перенос flex-элементов
Что будет, если флекс-элементов в контейнере станет больше, чем может уместиться в один ряд?

-   Они будут сжиматься до минимально возможной ширины.
-   Даже если им задать ширину явно, механизм флексбокса может её уменьшить.
-   Если они перестанут помещаться в контейнер и после уменьшения, то они выйдут за его пределы, но продолжат располагаться в один ряд.
Это чем-то похоже на поведение ячеек в таблице.
Такое поведение можно изменить свойством флекс-контейнера flex-wrap. По умолчанию оно имеет значение nowrap, то есть перенос флекс-элементов на новую строку запрещён.
Значение wrap разрешает перенос флекс-элементов на новую строку, если они не помещаются в контейнер.


Свойство flex-wrap: wrap-reverse, обратный перенос
Если перенос флекс-элементов разрешён, то ряды элементов располагаются вдоль поперечной оси. Первый ряд располагается в начале поперечной оси, а последний в конце. Но так работает только значение wrap.
Если для flex-wrap задать значение wrap-reverse, то элементы будут переноситься, а ряды будут располагаться в обратном порядке: первый в конце поперечной оси, а последний в начале.


Свойство align-content, выравнивание строк flex-контейнера
Вспомним свойство justify-content, которое управляет распределением флекс-элементов вдоль главной оси.
Есть очень похожее свойство align-content, которое управляет выравниванием рядов флекс-элементов вдоль поперечной оси. У этих свойств почти одинаковые значения:

-   flex-start,

-   flex-end,

-   center,

-   space-between,

-   space-around,

-   и stretch, которое есть у align-content, но нет у justify-content, и является значением по умолчанию.

Свойство align-content «перекрывает» заданное значение align-items, которое управляет выравниванием флекс-элементов вдоль поперечной оси. Это происходит и в случае, когда есть только один ряд флекс-элементов, и когда рядов несколько.
Ранее в спецификации было описано другое поведение:

-   если есть только один ряд флекс-элементов, то работает align-items;
-   если есть несколько рядов, то работает align-content.

Довольно долго такое поведение было во всех браузерах. Но в начале 2019 года поведение было актуализировано согласно спецификации во всех современных браузерах.


Свойство align-content: stretch и align-items
В случае одновременного задания align-items и align-content свойство align-items не отключается полностью, а может влиять на отображение флекс-элементов в рядах.
Это происходит, когда мы используем для align-content значение по умолчанию — stretch. Оно растягивает ряды флекс-элементов, при этом оставшееся свободное место между ними делится поровну.
Отображение строк при align-content: stretch зависит от значения align-items:

-   Если у align-items задано значение stretch, то элементы в строках растягиваются на всю высоту своей строки.
-   Если значение отлично от stretch, то элементы в строках ужимаются под своё содержимое и выравниваются в строках в зависимости от значения align-items.


Свойство align-content: не-stretch и align-items
Значение align-items влияет на отображение рядов во флекс-контейнере, если у align-content задано значение stretch. В этом мы убедились в прошлом задании.
Есть ли похожее влияние на остальные значения align-content? Нет.
Убедимся в этом на примере значения center, которое располагает ряды в середине поперечной оси так, что:

-   отступов между соседними рядами нет (но отступы самих элементов сохраняются),
-   расстояние между первым рядом и краем флекс-контейнера равно расстоянию между последним рядом и другим краем.


Свойство align-content, остальные значения
Остальные четыре значения свойства align-content аналогичны значениям свойства justify-content, отличается только ось:

-   flex-start располагает ряды в начале поперечной оси.

-   flex-end располагает ряды в конце поперечной оси.

-   space-between равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступов у краёв нет.

-   space-around равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступы у краёв равны половине расстояния между соседними рядами.

Напоследок небольшое резюме.
Свойство align-content — «гибридное». Мы переводим его как «выравнивание», но оно больше похоже на «распределение», justify-content, от которого оно позаимствовало два значения space-between и space-around.
Близость с «распределением» подчёркивает и отсутствие значения baseline — всё-таки свойство работает с рядами, а не с отдельными элементами.
От «выравниваний» же, align-items и align-self, это свойство получило значение по умолчанию stretch и возможность «растягивать» ряды по высоте.


Свойство order, порядковый номер flex-элемента
И ещё одно свойство, которое мы рассмотрим в этой главе, — это order, порядковый номер флекс-элемента.
Порядковый номер задаётся целым числом, положительным или отрицательным. Например:

.flex-element {
  order: -1; /* этот элемент станет отображаться первым в контейнере */
}

По умолчанию порядковый номер флекс-элементов равен 0, а сортировка элементов производится по возрастанию номера.
Это очень полезное свойство, так как с его помощью можно менять порядок следования флекс-элементов в потоке, не меняя HTML-код.


Идеальное центрирование, margin: auto у flex-контейнера
Теперь разберём примеры из жизни, в которых можно применять флексбокс.
Самый насущный вопрос, который можно легко и изящно решить с помощью флексбокса, — как отцентровать элемент по вертикали и горизонтали так, чтобы центровка сохранялась при изменении размеров элемента или контейнера.
Ответ прост: задать контейнеру раскладку флексбокса, а дочернему флекс-элементу margin: auto.
В этом случае флекс-элемент уменьшит свой размер под содержимое и отцентруется по вертикали и горизонтали.
Стоит обратить внимание на интересный момент. Если центруемых флекс-элементов в контейнере будет несколько, то отступы между ними будут равномерными. То есть будет происходить распределение элементов внутри флекс-контейнера чем-то похожее на justify-content: space-around.

Идеальное центрирование, flex-выравнивания
А теперь давайте отцентруем элементы с помощью свойств флекс-контейнера без margin: auto на дочерних элементах.
Заметьте разницу между тем, как распределяются элементы при разных значениях свойства justify-content.
Пример:

.block {
  display: flex;
  justify-content: space-around;
  align-items: center;
}


Адаптивное горизонтальное меню
Флексбокс полезен при создании блоков с дочерними элементами динамической длины. Хороший пример — меню.
Часто встречаются дизайны, в которых пункты равномерно распределены по блоку меню. Первый пункт примыкает к левой части блока меню, а последний — к правой, причём с небольшими внутренними отступами.
Эту задачу можно попытаться решить, задав фиксированные отступы и ширину пунктам меню. Но такой способ не подойдёт, если количество пунктов меню или подписи внутри них будут изменяться.
И тут на помощь приходит флексбокс. Зададим меню раскладку флексбокса, пункты станут флекс-элементами. С помощью свойства распределения элементов justify-content добьёмся нужного результата.
Теперь можно запросто добавить в меню ещё один пункт или изменить ширину самого контейнера.
Отступы между пунктами меню будут «гибко» меняться, подстраиваясь под новые условия.


Выравнивание блоков по высоте с помощью flexbox
Ещё одна часто встречающаяся задача — реализовать раскладку с блоками одинаковой высоты.
Надо учитывать, что содержимое блоков может быть разным и их высота может меняться.
В обычной блочной модели есть фундаментальный недостаток — соседние блоки ничего не знают друг о друге, поэтому их высоты нельзя «связать». Получается, что все «стандартные» варианты для решения этой задачи не работают:

-   float или inline-block не могут «связывать» высоты соседних блоков;

-   таблицы и CSS-таблицы позволяют делать ячейки одинаковой высоты, но появляются ограничения, связанные с расположением элементов в строках;

-   минимальная высота не подходит, так как какой-то из блоков всегда может стать выше остальных;

-   конечно, можно задать всем блокам фиксированную высоту, но это решение совсем не универсальное.
А с помощью флексбоксов эта проблема решается легко и изящно, ведь флекс-элементы по умолчанию растягиваются на всю высоту контейнера.


