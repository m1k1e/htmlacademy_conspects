Объединение селекторов
Иногда может потребоваться выбрать элементы, которые одновременно удовлетворяют сразу нескольким условиям.
В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:

.class1.class2 { }

Стили будут применяться ко всем элементам, которые одновременно имеют класс class1 и class2. Ведь это же не новость для вас, что HTML-элементы могут одновременно иметь несколько классов. Например:
<div class="class1 class2">Блок с двумя классами</div>

По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей.
В программировании похожую операцию часто обозначают как &&. Например:

if (firstSelector && secondSelector) { ... }

Псевдокласс :not
Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:
li:not(:last-child) { }

Этот селектор выберет все теги <li>, НЕ являющиеся последними в их родителе.
Псевдокласс :not похож на оператор ! в программировании:
if (!selector) { ... }

В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс :not, то есть конструкция :not(:not(...)) не сработает.
Также в комбинации с :not не применяются:
    объединение селекторов: например, li:not(.heart.jack) — некорректный селектор;
    псевдоэлементы: li:not(::after) — неправильная запись;
    селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).

Комбинируем :not
Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:
li:not(:first-child):not(:last-child) { }

Выберет все теги <li>, которые НЕ являются первыми и последними в их родителе.
Объединять можно неограниченное количество селекторов.

Псевдокласс :first-of-type
Псевдокласс :first-of-type очень похож на :first-child. Он выбирает первый дочерний элемент родителя, только с учетом типа элементов.
Например, в этом задании перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.

<body>
  <div class="paper"> … </div>
  <ul class="cards"> … </ul>
  <ul class="cards"> … </ul>
</body>

Сравним две записи:

ul:first-child {
  background-color: #ffffee;
}

ul:first-of-type {
  background-color: #ffffee;
}

Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul. В нашем случае не выберется ничего, потому что первым дочерним элементом body является div.
Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе.


Псевдокласс :last-of-type
В предыдущем задании мы рассмотрели псевдокласс :first-of-type.
Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.

Пример записи:

ul:last-of-type {
  ...
}


Псевдокласс :nth-of-type
Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента.
Вы можете обратиться к разбору примера в пятом задании, чтобы разобраться в отличиях этих селекторов.
Еще пример. Если в текущем задании мы используем такие селекторы:

ul:nth-child(2) { }
ul:nth-of-type(2) { }

То верхний cелектор выберет второй по счёту дочерний элемент и этот элемент должен быть ul. В нашем случае выберется первая строка карт.
А нижний селектор выберет второй по счету ul среди дочерних ul. В нашем случае выберется вторая строка карт.
Псевдокласс :nth-of-type также работает с ключевыми словами odd и even. Значение odd позволяет выбрать все нечётные элементы, а значение even - все чётные элементы указанного типа. Подробнее о работе с этими ключевыми словами рассказано в пошаговой демонстрации Использование псевдокласса :nth-child.
https://htmlacademy.ru/demos/2#1
https://habr.com/ru/post/119139/


Псевдокласс :nth-last-of-type
Наверняка, вы и сами уже прекрасно догадались, как будет работать :nth-last-of-type.
Элементы выбираются по их расположению, отсчет ведется от конца, учитывается тип элемента.
Пример записи:

ul:nth-last-of-type(2) { }

Когда набор элементов не очень большой, все эти псевдоклассы :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type можно легко заменить один другим.
На более сложных структурах зачастую бывает удобнее использовать только определённые из них. Например, когда нужно выделять второй элемент с конца, но количество элементов в списке изменяется.


Cелектор последующих элементов
Ранее мы уже рассматривали соседние селекторы, которые записываются как селектор1 + селектор2.
Есть похожий селектор селектор1 ~ селектор2. Стили применятся к элементу, подходящему под селектор2, только если перед ним расположен элемент, подходящий под селектор1. Оба элемента должны принадлежать одному родителю.
Отличие от соседнего селектора состоит в том, что между элементами селектор1 и селектор2 могут находиться другие элементы. Поэтому будем называть селектор1 ~ селектор2 селектором следующих элементов.

Сравним:

<ul class="cards">
  <li class="king diamond">
  <li class="queen heart">
  <li class="jack spade">
  <li class="ace heart">
  <li class="king club">
</ul>
.queen.heart + li {
  background-color: #ffff99;
}

.king.diamond ~ li {
  background-color: #99ddff;
}

В первом случае выделится одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.
Во втором случае выделятся все карты, которые стоят за бубновым королем, то есть червовая дама, пиковый валет, червовый туз и трефовый король.


Псевдокласс :empty
Псевдокласс :empty, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считается текстовым узлом, помните об этом в процессе проектирования структуры страницы.
Пример:

ul:empty {
  ...
}

В данном случае выберутся все пустые элементы ul.


Псевдокласс :only-child
Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.
Пример:

li:only-child {
  ...
}

Сработает, когда этот <li> в списке единственный.
Cелектор :only-child эквивалентен селектору elem:last-child:first-child.


Псевдокласс :only-of-type
Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.
Пример:

p:only-of-type {
  ...
}

В данном случае стили будут применены к элементу p, если это единственный p внутри своего родителя.


Псевдоэлемент ::before
Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.
Например, у нас есть такой HTML:

<div class="queen heart">
  <em>Дама</em>
</div>

Добавим CSS-правило с необычным селектором с двойным двоеточием:

.heart::before { content: "Черви"; }

И HTML изменится вот так:

<div class="queen heart">
  <before>Черви</before>
  <em>Дама</em>
</div>

Но! Исходный HTML-код не изменится, тег <before> не попадёт в код страницы, а будет «виртуально» существовать где-то в браузере. Поэтому мы и используем приставку псевдо.
Ведёт себя псевдотег так же, как обычный <span> с текстом. Ему можно задавать дополнительные стили, например:

.heart::before {
  content: "Черви";
  color: red;
}

Чтобы псевдоэлемент появился, ему необходимо задать свойство content. Достаточно даже пустой строки в значении свойства — content: "";.


Псевдоэлемент ::after
Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента. Например:

.heart::after { content: "Черви"; }

Даст такой результат:

<div class="queen heart">
  <em>Дама</em>
  <after>Черви</after>
</div>

Псевдоэлементы before и after можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любому элементу на странице два псевдоэлемента.
Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.
В старом варианте стандарта псевдоэлементы можно было использовать с :. Поэтому запись с : понимают и очень старые браузеры. Но сейчас использовать одинарное двоеточие для псевдоэлементов считается дурным тоном.


Позиционирование псевдоэлементов
Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.
Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно.
Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку.
Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.


Псевдоэлементы ::first-line и ::first-letter
Отвлечемся от карт и обратимся к тексту.
Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.
Пример использования:

p::first-line { }

Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.
Пример использования:

p::first-letter { }
